//
// Created by villerot on 17/03/25.
// Updated on 03/10/25.
// Documentation generated by ChatGPT
// Based of Vraid Code
// https://github.com/vraid/earthgen-old/blob/master/source/math/quaternion.cpp
//

// External Lib
#include <stdexcept>
#include <cmath>
#include <iostream>

// Internal
#include "Quaternion.h"
#include "Vector3D.h"
#include "../Math/Vector.hpp"
#include "../Math/math_common.h"

namespace geometry {

    // Static constant definition
    const Quaternion Quaternion::IDENTITY(1.0, 0.0, 0.0, 0.0);

    // Constructors

    Quaternion::Quaternion() {
        // Initialize as identity quaternion (1, 0, 0, 0)
        components[0] = 1.0;  // w
        components[1] = 0.0;  // x
        components[2] = 0.0;  // y
        components[3] = 0.0;  // z
    }

    Quaternion::Quaternion(double w, double x, double y, double z) {
        components[0] = w;
        components[1] = x;
        components[2] = y;
        components[3] = z;
    }

    Quaternion::Quaternion(const Vector3D& axis, double angle) {
        // Normalize the axis
        Vector3D normalizedAxis = axis.normal();
        
        // Half angle
        double halfAngle = angle * 0.5;
        double sinHalfAngle = std::sin(halfAngle);
        double cosHalfAngle = std::cos(halfAngle);
        
        components[0] = cosHalfAngle;                            // w
        components[1] = normalizedAxis.x() * sinHalfAngle;       // x
        components[2] = normalizedAxis.y() * sinHalfAngle;       // y
        components[3] = normalizedAxis.z() * sinHalfAngle;       // z
    }

    Quaternion::Quaternion(const math::Vector<double>& comp) {
        if (comp.size() != 4) {
            throw std::invalid_argument("Vector must be 4D to convert to Quaternion");
        }
        components[0] = *comp[0];
        components[1] = *comp[1];
        components[2] = *comp[2];
        components[3] = *comp[3];
    }

    // Component accessor
    double Quaternion::at(int index) const {
        if (index < 0 || index >= 4) {
            throw std::out_of_range("Quaternion index out of bounds");
        }
        return components[index];
    }

    // Component mutators

    void Quaternion::setW(double w_val) {
        components[0] = w_val;
    }

    void Quaternion::setX(double x_val) {
        components[1] = x_val;
    }

    void Quaternion::setY(double y_val) {
        components[2] = y_val;
    }

    void Quaternion::setZ(double z_val) {
        components[3] = z_val;
    }

    void Quaternion::set(double w_val, double x_val, double y_val, double z_val) {
        components[0] = w_val;
        components[1] = x_val;
        components[2] = y_val;
        components[3] = z_val;
    }

    // Static factory methods

    Quaternion Quaternion::identity() {
        return Quaternion(1.0, 0.0, 0.0, 0.0);
    }

    Quaternion Quaternion::fromAxisAngle(const Vector3D& axis, double angle) {
        return Quaternion(axis, angle);
    }

    Quaternion Quaternion::fromVectorToVector(const Vector3D& from, const Vector3D& to) {
        Vector3D fromNorm = from.normal();
        Vector3D toNorm = to.normal();

        double cosTheta = fromNorm.dot(toNorm);
        
        // Check if vectors are parallel (same direction)
        if (cosTheta > 0.9999) {
            return identity();
        }
        
        // Check if vectors are opposite
        if (cosTheta < -0.9999) {
            // Find a perpendicular axis
            Vector3D axis(1.0, 0.0, 0.0);
            if (std::abs(fromNorm.x()) > 0.1) {
                axis = Vector3D(0.0, 1.0, 0.0);
            }
            
            // Create perpendicular vector using cross product
            Vector3D perpendicular = fromNorm.cross(axis);
            
            return Quaternion(perpendicular.normal(), math::pi);
        }
        
        // Calculate rotation axis using cross product
        Vector3D rotationAxis = fromNorm.cross(toNorm);
        
        // Calculate angle
        double angle = std::acos(cosTheta);
        
        return Quaternion(rotationAxis.normal(), angle);
    }

    Quaternion Quaternion::fromEulerAngles(double roll, double pitch, double yaw) {
        // Half angles
        double cr = std::cos(roll * 0.5);
        double sr = std::sin(roll * 0.5);
        double cp = std::cos(pitch * 0.5);
        double sp = std::sin(pitch * 0.5);
        double cy = std::cos(yaw * 0.5);
        double sy = std::sin(yaw * 0.5);

        // ZYX convention (yaw-pitch-roll)
        double w = cr * cp * cy + sr * sp * sy;
        double x = sr * cp * cy - cr * sp * sy;
        double y = cr * sp * cy + sr * cp * sy;
        double z = cr * cp * sy - sr * sp * cy;

        return Quaternion(w, x, y, z);
    }

    // Operators

    Quaternion Quaternion::operator*(const Quaternion& other) const {
        // Hamilton product: q1 * q2
        // Formula: (w1*w2 - v1·v2, w1*v2 + w2*v1 + v1×v2)
        // Where w is scalar part and v is vector part
        
        double w1 = this->w(), x1 = this->x(), y1 = this->y(), z1 = this->z();
        double w2 = other.w(), x2 = other.x(), y2 = other.y(), z2 = other.z();
        
        // Calculate new components using Hamilton product formula
        double w = w1*w2 - x1*x2 - y1*y2 - z1*z2;  // Scalar part
        double x = w1*x2 + x1*w2 + y1*z2 - z1*y2;  // i component
        double y = w1*y2 - x1*z2 + y1*w2 + z1*x2;  // j component
        double z = w1*z2 + x1*y2 - y1*x2 + z1*w2;  // k component
        
        return Quaternion(w, x, y, z);
    }

    Vector3D Quaternion::operator*(const Vector3D& v) const {
        // Rotate vector v by this quaternion using the formula:
        // v' = q * v * q^(-1)
        // Where q^(-1) is the conjugate for unit quaternions
        
        // For efficiency, we use the expanded formula:
        // v' = v + 2*w*cross(qv, v) + 2*cross(qv, cross(qv, v))
        // Where qv is the vector part of the quaternion and w is the scalar part
        
        Vector3D qv(this->x(), this->y(), this->z());  // Vector part of quaternion
        double qw = this->w();  // Scalar part of quaternion
        
        // Calculate cross products
        Vector3D cross1 = qv.cross(v);
        Vector3D cross2 = qv.cross(cross1);
        
        // Apply rotation formula
        Vector3D result = v + cross1 * (2.0 * qw) + cross2 * 2.0;
        
        return result;
    }

    Quaternion Quaternion::operator+(const Quaternion& other) const {
        // Component-wise addition of quaternions
        // Note: This is mathematically valid but doesn't represent rotation composition
        // For rotation composition, use quaternion multiplication (*)
        // Addition is useful for interpolation and averaging quaternions
        
        return Quaternion(
            this->w() + other.w(),  // w component
            this->x() + other.x(),  // x component
            this->y() + other.y(),  // y component
            this->z() + other.z()   // z component
        );
    }

    Quaternion Quaternion::operator-(const Quaternion& other) const {
        // Component-wise subtraction of quaternions
        // Note: This is mathematically valid but doesn't represent rotation composition
        // For rotation composition, use quaternion multiplication (*)
        // Addition is useful for interpolation and averaging quaternions
        
        return Quaternion(
            this->w() - other.w(),  // w component
            this->x() - other.x(),  // x component
            this->y() - other.y(),  // y component
            this->z() - other.z()   // z component
        );
    }

    Quaternion Quaternion::operator*(double scalar) const {
        // Component-wise multiplication of quaternion by a scalar
        return Quaternion(
            this->w() * scalar,  // w component
            this->x() * scalar,  // x component
            this->y() * scalar,  // y component
            this->z() * scalar   // z component
        );
    }

    Quaternion Quaternion::conjugate() const {
        return Quaternion(
            this->w(),
            -this->x(),
            -this->y(),
            -this->z()
        );
    }

    Quaternion Quaternion::inverse() const {
        double normSq = this->lengthSquared();
        if (normSq == 0.0) {
            throw std::runtime_error("Cannot invert a zero-length quaternion");
        }
        return this->conjugate() * (1.0 / normSq);
    }

    Quaternion Quaternion::normalize() const {
        double len = this->length();
        if (len == 0.0) {
            throw std::invalid_argument("Cannot normalize a zero-length quaternion.");
        }
        return (*this) * (1.0 / len);
    }

    void Quaternion::normalizeInPlace() {
        double len = this->length();
        if (len == 0.0) {
            throw std::invalid_argument("Cannot normalize a zero-length quaternion.");
        }
        for (int i = 0; i < 4; ++i) {
            components[i] /= len;
        }
    }

    // Add length methods for quaternion
    double Quaternion::length() const {
        return std::sqrt(lengthSquared());
    }

    double Quaternion::lengthSquared() const {
        return components[0] * components[0] + 
               components[1] * components[1] + 
               components[2] * components[2] + 
               components[3] * components[3];
    }
    
    Vector3D Quaternion::vectorPart() const {
        return Vector3D(this->x(), this->y(), this->z());
    }

    math::Matrix<double> Quaternion::toRotationMatrix3x3() const {
        // Ensure the quaternion is normalized
        Quaternion q = this->normalize();

        double w = q.w();
        double x = q.x();
        double y = q.y();
        double z = q.z();

        // Create a 3x3 rotation matrix
        math::Matrix<double> rotMatrix(3, 3);

        // Allocate and set matrix elements
        double* elem00 = new double(1.0 - 2.0 * y * y - 2.0 * z * z);
        double* elem01 = new double(2.0 * x * y - 2.0 * z * w);
        double* elem02 = new double(2.0 * x * z + 2.0 * y * w);
        double* elem10 = new double(2.0 * x * y + 2.0 * z * w);
        double* elem11 = new double(1.0 - 2.0 * x * x - 2.0 * z * z);
        double* elem12 = new double(2.0 * y * z - 2.0 * x * w);
        double* elem20 = new double(2.0 * x * z - 2.0 * y * w);
        double* elem21 = new double(2.0 * y * z + 2.0 * x * w);
        double* elem22 = new double(1.0 - 2.0 * x * x - 2.0 * y * y);

        rotMatrix(0, 0) = elem00;
        rotMatrix(0, 1) = elem01;
        rotMatrix(0, 2) = elem02;
        rotMatrix(1, 0) = elem10;
        rotMatrix(1, 1) = elem11;
        rotMatrix(1, 2) = elem12;
        rotMatrix(2, 0) = elem20;
        rotMatrix(2, 1) = elem21;
        rotMatrix(2, 2) = elem22;

        return rotMatrix;
    }

    math::Matrix<double> Quaternion::toRotationMatrix4x4() const {
        // Ensure the quaternion is normalized
        Quaternion q = this->normalize();

        double w = q.w();
        double x = q.x();
        double y = q.y();
        double z = q.z();

        // Create a 4x4 rotation matrix
        math::Matrix<double> rotMatrix(4, 4);

        // Allocate and set matrix elements for 4x4 matrix
        rotMatrix(0, 0) = new double(1.0 - 2.0 * y * y - 2.0 * z * z);
        rotMatrix(0, 1) = new double(2.0 * x * y - 2.0 * z * w);
        rotMatrix(0, 2) = new double(2.0 * x * z + 2.0 * y * w);
        rotMatrix(0, 3) = new double(0.0);

        rotMatrix(1, 0) = new double(2.0 * x * y + 2.0 * z * w);
        rotMatrix(1, 1) = new double(1.0 - 2.0 * x * x - 2.0 * z * z);
        rotMatrix(1, 2) = new double(2.0 * y * z - 2.0 * x * w);
        rotMatrix(1, 3) = new double(0.0);

        rotMatrix(2, 0) = new double(2.0 * x * z - 2.0 * y * w);
        rotMatrix(2, 1) = new double(2.0 * y * z + 2.0 * x * w);
        rotMatrix(2, 2) = new double(1.0 - 2.0 * x * x - 2.0 * y * y);
        rotMatrix(2, 3) = new double(0.0);

        rotMatrix(3, 0) = new double(0.0);
        rotMatrix(3, 1) = new double(0.0);
        rotMatrix(3, 2) = new double(0.0);
        rotMatrix(3, 3) = new double(1.0);

        return rotMatrix;
    }

    double Quaternion::getRotationAngle() const {
        // Ensure the quaternion is normalized
        Quaternion q = this->normalize();

        // Calculate the rotation angle (full angle, not half-angle)
        return 2.0 * std::acos(std::abs(q.w()));
    }

    Vector3D Quaternion::getRotationAxis() const {
        // Ensure the quaternion is normalized
        Quaternion q = this->normalize();

        // Calculate the sine of half-angle
        double s = std::sqrt(1.0 - q.w() * q.w());

        // Check if this represents no rotation (identity quaternion)
        if (s < 0.001) { 
            // If s is close to zero, the quaternion is close to identity
            // This means no rotation or 360° rotation
            throw std::invalid_argument("Quaternion represents no rotation (identity quaternion)");
        } else {
            // Extract the normalized rotation axis
            return Vector3D(q.x() / s, q.y() / s, q.z() / s);
        }
    }

    void Quaternion::toAxisAngle(Vector3D& axis, double& angle) const {
        angle = getRotationAngle();
        axis = getRotationAxis();
    }

    bool Quaternion::isUnit(double epsilon) const {
        return std::abs(this->lengthSquared() - 1.0) < epsilon;
    }

    Quaternion Quaternion::fromRotationMatrix(const math::Matrix<double>& rotationMatrix) {
        if (rotationMatrix.getRows() != static_cast<size_t>(3) || rotationMatrix.getCols() != static_cast<size_t>(3)) {
            throw std::invalid_argument("Rotation matrix must be 3x3");
        }

        double m00 = *(rotationMatrix(0, 0));
        double m11 = *(rotationMatrix(1, 1));
        double m22 = *(rotationMatrix(2, 2));
        double trace = m00 + m11 + m22;

        double w, x, y, z;

        if (trace > 0) {
            double s = std::sqrt(trace + 1.0) * 2.0; // S=4*qw
            w = 0.25 * s;
            x = (*(rotationMatrix(2, 1)) - *(rotationMatrix(1, 2))) / s;
            y = (*(rotationMatrix(0, 2)) - *(rotationMatrix(2, 0))) / s;
            z = (*(rotationMatrix(1, 0)) - *(rotationMatrix(0, 1))) / s;
        } else if ((m00 > m11) && (m00 > m22)) {
            double s = std::sqrt(1.0 + m00 - m11 - m22) * 2.0; // S=4*qx
            w = (*(rotationMatrix(2, 1)) - *(rotationMatrix(1, 2))) / s;
            x = 0.25 * s;
            y = (*(rotationMatrix(0, 1)) + *(rotationMatrix(1, 0))) / s;
            z = (*(rotationMatrix(0, 2)) + *(rotationMatrix(2, 0))) / s;
        } else if (m11 > m22) {
            double s = std::sqrt(1.0 + m11 - m00 - m22) * 2.0; // S=4*qy
            w = (*(rotationMatrix(0, 2)) - *(rotationMatrix(2, 0))) / s;
            x = (*(rotationMatrix(0, 1)) + *(rotationMatrix(1, 0))) / s;
            y = 0.25 * s;
            z = (*(rotationMatrix(1, 2)) + *(rotationMatrix(2, 1))) / s;
        } else {
            double s = std::sqrt(1.0 + m22 - m00 - m11) * 2.0; // S=4*qz
            w = (*(rotationMatrix(1, 0)) - *(rotationMatrix(0, 1))) / s;
            x = (*(rotationMatrix(0, 2)) + *(rotationMatrix(2, 0))) / s;
            y = (*(rotationMatrix(1, 2)) + *(rotationMatrix(2, 1))) / s;
            z = 0.25 * s;
        }

        return Quaternion(w, x, y, z);
    }

    

    double Quaternion::dot(const Quaternion& other) const {
        return this->w() * other.w() + this->x() * other.x() + this->y() * other.y() + this->z() * other.z();
    }

    // Interpolation methods

    Quaternion Quaternion::slerp(const Quaternion& q1, const Quaternion& q2, double t) {
        // Clamp t to [0, 1]
        t = std::max(0.0, std::min(1.0, t));
        
        // Ensure both quaternions are normalized
        Quaternion qa = q1.normalize();
        Quaternion qb = q2.normalize();
        
        // Compute the dot product
        double dot = qa.dot(qb);
        
        // If the dot product is negative, slerp won't take the shorter path.
        // Note that v1 and -v1 are equivalent when the quaternions are used to represent rotations.
        if (dot < 0.0) {
            qb = qb * (-1.0);  // Flip the quaternion
            dot = -dot;
        }
        
        // If the quaternions are very close, use linear interpolation to avoid division by zero
        const double DOT_THRESHOLD = 0.9995;
        if (dot > DOT_THRESHOLD) {
            // Linear interpolation for very close quaternions
            Quaternion result = qa + (qb - qa) * t;
            return result.normalize();
        }
        
        // Calculate the half angle between the quaternions
        double theta_0 = std::acos(dot);
        double theta = theta_0 * t;
        
        // Compute the quaternion orthogonal to qa in the plane spanned by qa and qb
        Quaternion qb_perp = qb - qa * dot;
        qb_perp = qb_perp.normalize();
        
        // Perform spherical linear interpolation
        return qa * std::cos(theta) + qb_perp * std::sin(theta);
    }

    Quaternion Quaternion::nlerp(const Quaternion& q1, const Quaternion& q2, double t) {
        // Clamp t to [0, 1]
        t = std::max(0.0, std::min(1.0, t));
        
        // Ensure both quaternions are normalized
        Quaternion qa = q1.normalize();
        Quaternion qb = q2.normalize();
        
        // Check if we need to flip qb to take the shorter path
        double dot = qa.dot(qb);
        if (dot < 0.0) {
            qb = qb * (-1.0);  // Flip the quaternion
        }
        
        // Linear interpolation
        Quaternion result = qa * (1.0 - t) + qb * t;
        
        // Normalize the result
        return result.normalize();
    }

    // Print
    std::ostream& operator<<(std::ostream& os, const Quaternion& q) {
            os << "Quaternion(" << q.w() << ", " << q.x() << ", " << q.y() << ", " << q.z() << ")";
            return os;
    }
}

// Note: Need to add toRotationMatrix4x4 method implementation here if needed
