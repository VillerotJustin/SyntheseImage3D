//
// Created by villerot on 17/03/25.
// Updated on 03/10/25.
// Documentation generated by Copilot
// Based of Vraid Code
// https://github.com/vraid/earthgen-old/blob/master/source/math/quaternion.h
//

#ifndef QUATERNION_H
#define QUATERNION_H

#include "../Math/Matrix.hpp"
#include "../Math/Vector.hpp"
#include "Vector3D.h"
#include "../Math/math_common.h"

namespace geometry {

    /**
     * @class Quaternion
     * @brief A quaternion class for 3D rotations using composition.
     * 
     * This class represents quaternions as 4D mathematical entities [w, x, y, z] where:
     * - w is the scalar (real) part
     * - x, y, z are the vector (imaginary) parts
     * 
     * Quaternions provide a robust way to represent rotations in 3D space
     * without gimbal lock and with efficient composition operations.
     */
    class Quaternion {
    public:
        
        // Constructors
        
        /**
         * @brief Default constructor for Quaternion.
         * Initializes the quaternion as identity quaternion (1, 0, 0, 0).
         */
        Quaternion();

        /**
         * @brief Parameterized constructor for Quaternion.
         * Initializes the quaternion with the specified components.
         *
         * @param w The real (scalar) component of the quaternion.
         * @param x The first imaginary component of the quaternion.
         * @param y The second imaginary component of the quaternion.
         * @param z The third imaginary component of the quaternion.
         */
        Quaternion(double w, double x, double y, double z);

        /**
         * @brief Constructor from axis and angle.
         * Creates a quaternion representing rotation around an axis.
         *
         * @param axis The rotation axis (will be normalized).
         * @param angle The rotation angle in radians.
         */
        Quaternion(const Vector3D& axis, double angle);

        /**
         * @brief Copy constructor from Vector template.
         * Converts a 4D vector to quaternion.
         *
         * @param components The 4D vector to convert [w, x, y, z].
         * @throws std::invalid_argument if vector is not 4D.
         */
        explicit Quaternion(const math::Vector<double>& components);

        // Component accessors with semantic names
        
        /**
         * @brief Get the scalar (real) component.
         * @return The w component of the quaternion.
         */
        [[nodiscard]] double w() const { return components[0]; }

        /**
         * @brief Get the x component.
         * @return The x component of the quaternion.
         */
        [[nodiscard]] double x() const { return components[1]; }

        /**
         * @brief Get the y component.
         * @return The y component of the quaternion.
         */
        [[nodiscard]] double y() const { return components[2]; }

        /**
         * @brief Get the z component.
         * @return The z component of the quaternion.
         */
        [[nodiscard]] double z() const { return components[3]; }

        /**
         * @brief Accessor method to get the value at a specific index.
         * @param index The index (0=w, 1=x, 2=y, 3=z).
         * @return The value at the specified index.
         * @throws std::out_of_range if index is out of bounds.
         */
        [[nodiscard]] double at(int index) const;

        /**
         * @brief Get the size of the quaternion (always 4).
         * @return The size (4).
         */
        [[nodiscard]] int size() const { return 4; }

        // Component mutators
        
        /**
         * @brief Set the scalar component.
         * @param w_val The new w value.
         */
        void setW(double w_val);

        /**
         * @brief Set the x component.
         * @param x_val The new x value.
         */
        void setX(double x_val);

        /**
         * @brief Set the y component.
         * @param y_val The new y value.
         */
        void setY(double y_val);

        /**
         * @brief Set the z component.
         * @param z_val The new z value.
         */
        void setZ(double z_val);

        /**
         * @brief Set all quaternion components.
         * @param w_val The scalar component.
         * @param x_val The x component.
         * @param y_val The y component.
         * @param z_val The z component.
         */
        void set(double w_val, double x_val, double y_val, double z_val);

        // Quaternion-specific operators
        
        /**
         * @brief Quaternion multiplication operator.
         * Computes the Hamilton product of two quaternions.
         * !!!!!!!! Non-commutative !!!!!!!!
         *
         * @param other The quaternion to multiply with.
         * @return A new quaternion representing the combined rotation.
         */
        Quaternion operator*(const Quaternion& other) const;

        /**
         * @brief Vector rotation operator.
         * Rotates a 3D vector by this quaternion.
         *
         * @param v The 3D vector to rotate.
         * @return The rotated vector.
         */
        Vector3D operator*(const Vector3D& v) const;

        // Override operators to return Quaternion instead of Vector
        
        /**
         * @brief Quaternion addition.
         * @param other The quaternion to add.
         * @return Sum of quaternions.
         */
        Quaternion operator+(const Quaternion& other) const;

        /**
         * @brief Quaternion subtraction.
         * @param other The quaternion to subtract.
         * @return Difference of quaternions.
         */
        Quaternion operator-(const Quaternion& other) const;

        /**
         * @brief Scalar multiplication.
         * @param scalar The scalar to multiply by.
         * @return Scaled quaternion.
         */
        Quaternion operator*(double scalar) const;

        // Quaternion-specific methods
        
        /**
         * @brief Get the conjugate of this quaternion.
         * The conjugate has the same w but negated x, y, z components.
         *
         * @return The conjugate quaternion.
         */
        Quaternion conjugate() const;

        /**
         * @brief Get the inverse of this quaternion.
         * For unit quaternions, inverse equals conjugate.
         *
         * @return The inverse quaternion.
         * @throws std::invalid_argument if quaternion has zero magnitude.
         */
        Quaternion inverse() const;

        /**
         * @brief Normalize this quaternion to unit length.
         * @return A normalized quaternion.
         * @throws std::invalid_argument if quaternion has zero magnitude.
         */
        Quaternion normalize() const;

        /**
         * @brief Normalize this quaternion in place.
         * @throws std::invalid_argument if quaternion has zero magnitude.
         */
        void normalizeInPlace();

        /**
         * @brief Get the vector part (imaginary components) of the quaternion.
         * @return A 3D vector containing [x, y, z] components.
         */
        Vector3D vectorPart() const;

        /**
         * @brief Convert quaternion to 3x3 rotation matrix.
         * @return A 3x3 matrix representing the rotation.
         * @note Quaternion should be normalized for correct results.
         */
        math::Matrix<double> toRotationMatrix3x3() const;

        /**
         * @brief Convert quaternion to 4x4 rotation matrix.
         * @return A 4x4 homogeneous transformation matrix.
         * @note Quaternion should be normalized for correct results.
         */
        math::Matrix<double> toRotationMatrix4x4() const;

        /**
         * @brief Get rotation axis and angle from quaternion.
         * @param axis Output parameter for the rotation axis.
         * @param angle Output parameter for the rotation angle in radians.
         * @throws std::invalid_argument if quaternion represents no rotation.
         */
        void toAxisAngle(Vector3D& axis, double& angle) const;

        /**
         * @brief Calculate the angle of rotation represented by this quaternion.
         * @return The rotation angle in radians.
         */
        double getRotationAngle() const;

        /**
         * @brief Get the rotation axis of this quaternion.
         * @return The normalized rotation axis.
         * @throws std::invalid_argument if quaternion represents no rotation.
         */
        Vector3D getRotationAxis() const;

        /**
         * @brief Check if this is a unit quaternion.
         * @param epsilon Tolerance for the check (default: 1e-9).
         * @return True if the quaternion is normalized.
         */
        bool isUnit(double epsilon = 1e-9) const;

        /**
         * @brief Get the length (magnitude) of the quaternion.
         * @return The length of the quaternion.
         */
        [[nodiscard]] double length() const;

        /**
         * @brief Get the squared length of the quaternion.
         * @return The squared length of the quaternion.
         */
        [[nodiscard]] double lengthSquared() const;

        // Static factory methods
        
        /**
         * @brief Create identity quaternion.
         * @return Identity quaternion (1, 0, 0, 0).
         */
        static Quaternion identity();

        /**
         * @brief Create quaternion from axis-angle representation.
         * @param axis The rotation axis (will be normalized).
         * @param angle The rotation angle in radians.
         * @return The quaternion representing the rotation.
         */
        static Quaternion fromAxisAngle(const Vector3D& axis, double angle);

        /**
         * @brief Create quaternion representing rotation between two 3D vectors.
         * @param from The source vector.
         * @param to The target vector.
         * @return Quaternion that rotates 'from' to 'to'.
         */
        static Quaternion fromVectorToVector(const Vector3D& from, const Vector3D& to);

        /**
         * @brief Create quaternion from Euler angles (ZYX convention).
         * @param roll Rotation around X-axis (radians).
         * @param pitch Rotation around Y-axis (radians).
         * @param yaw Rotation around Z-axis (radians).
         * @return The quaternion representing the combined rotation.
         */
        static Quaternion fromEulerAngles(double roll, double pitch, double yaw);

        /**
         * @brief Create quaternion from 3x3 rotation matrix.
         * @param matrix The 3x3 rotation matrix.
         * @return The equivalent quaternion.
         * @throws std::invalid_argument if matrix is not 3x3.
         */
        static Quaternion fromRotationMatrix(const math::Matrix<double>& matrix);

        // Interpolation methods
        
        /**
         * @brief Spherical linear interpolation between two quaternions.
         * @param q1 First quaternion.
         * @param q2 Second quaternion.
         * @param t Interpolation parameter [0, 1].
         * @return Interpolated quaternion.
         */
        static Quaternion slerp(const Quaternion& q1, const Quaternion& q2, double t);

        /**
         * @brief Normalized linear interpolation between two quaternions.
         * Faster than SLERP but less accurate for large angles.
         * @param q1 First quaternion.
         * @param q2 Second quaternion.
         * @param t Interpolation parameter [0, 1].
         * @return Interpolated quaternion.
         */
        static Quaternion nlerp(const Quaternion& q1, const Quaternion& q2, double t);

        /**
         * @brief Calculate dot product of two quaternions.
         * @param q1 First quaternion.
         * @param q2 Second quaternion.
         * @return Dot product value.
         */
        double dot(const Quaternion& other) const;

        // Common quaternion constants
        static const Quaternion IDENTITY;

    private:
        double components[4]; ///< Array storing w, x, y, z components
        static constexpr double EPSILON = 1e-9; ///< Epsilon for floating point comparisons
    };

    // Non-member utility functions

    /**
     * @brief Output stream operator for quaternions.
     * @param os Output stream.
     * @param q Quaternion to output.
     * @return Reference to output stream.
     */
    std::ostream& operator<<(std::ostream& os, const Quaternion& q);

} // namespace geometry

#endif //QUATERNION_H

