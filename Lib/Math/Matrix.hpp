//
// Created by villerot on 17/03/25.
// Updated by villerot on 01/10/25.
// Documentation generated by ChatGPT
//

#ifndef MATRIX_H
#define MATRIX_H

#include <iostream>

namespace math {
    /**
     * Template class representing a matrix of pointers to objects of type T.
     * Provides basic matrix operations for pointer management.
     */
    template<typename T>
    class Matrix {
    public:

        // Constructors & destructors

        /**
         * Constructor that initializes a matrix with the specified number of rows and columns.
         * All pointers are initialized to nullptr.
         *
         * @param rows The number of rows in the matrix.
         * @param cols The number of columns in the matrix.
         */
    Matrix(size_t rows, size_t cols);

        /**
         * Constructor that initializes a matrix using a given 2D array of pointers.
         *
         * @param a The 2D array containing matrix element pointers.
         * @param rows The number of rows in the matrix.
         * @param cols The number of columns in the matrix.
         */
    Matrix(T*** a, size_t rows, size_t cols);

        /**
         * Default constructor that initializes a 1x1 matrix with a nullptr.
         */
        Matrix();

        /**
         * Destructor that deallocates the memory used by the matrix.
         * Note: This does NOT delete the objects pointed to by the pointers.
         * That responsibility lies with the user.
         */
        ~Matrix();

        /**
         * Copy constructor that creates a new matrix by copying the pointer values from another matrix.
         * This performs a shallow copy - the actual objects are not duplicated.
         *
         * @param other The matrix to copy.
         */
        Matrix(const Matrix& other);

        // Operators

        /**
         * Overloaded operator for element access.
         * Provides access to matrix element pointers.
         *
         * @param x Row index.
         * @param y Column index.
         * @return Reference to the pointer at (x, y).
         */
    inline T*& operator()(const size_t x, const size_t y) { return p[x][y]; }

        /**
         * Overloaded operator for element access (const version).
         * Provides access to matrix element pointers for read-only purposes.
         *
         * @param x Row index.
         * @param y Column index.
         * @return Const reference to the pointer at (x, y).
         */
    inline const T* operator()(const size_t x, const size_t y) const { return p[x][y]; }

        /**
         * Overloaded assignment operator that copies pointer values from another matrix.
         * This performs a shallow copy - the actual objects are not duplicated.
         *
         * @param other The matrix to copy.
         * @return The current matrix after the assignment.
         */
        Matrix& operator=(const Matrix& other);

        /**
         * Swaps two rows of the matrix.
         *
         * @param r1 The index of the first row.
         * @param r2 The index of the second row.
         */
    void swapRows(size_t r1, size_t r2);

        /**
         * Returns the transpose of the matrix.
         *
         * @return The transposed matrix.
         */
        Matrix transpose();

        /**
         * Sets all pointers in the matrix to nullptr.
         */
        void clear();

        /**
         * Gets the number of rows in the matrix.
         *
         * @return The number of rows.
         */
    size_t getRows() const;

        /**
         * Gets the number of columns in the matrix.
         *
         * @return The number of columns.
         */
    size_t getCols() const;

        /**
         * Overloaded output stream operator to print the matrix addresses.
         *
         * @param os The output stream.
         * @param m The matrix to print.
         * @return The output stream with the matrix printed.
         */
        template<typename U>
        friend std::ostream& operator<<(std::ostream& os, const Matrix<U>& m);

    private:
    size_t rows_, cols_;
        T ***p{}; /// Pointer to the 2D array holding the matrix pointers

        /**
        * Allocates memory for the matrix pointers.
        */
        void allocSpace();
    };

    /* TEMPLATE IMPLEMENTATION */

    template<typename T>
    Matrix<T>::Matrix(const size_t rows, const size_t cols) : rows_(rows), cols_(cols)
    {
        allocSpace();
        for (size_t i = 0; i < rows_; ++i) {
            for (size_t j = 0; j < cols_; ++j) {
                p[i][j] = nullptr;
            }
        }
    }

    template<typename T>
    Matrix<T>::Matrix(T*** a, const size_t rows, const size_t cols) : rows_(rows), cols_(cols)
    {
        allocSpace();
        for (size_t i = 0; i < rows_; ++i) {
            for (size_t j = 0; j < cols_; ++j) {
                p[i][j] = a[i][j];
            }
        }
    }

    template<typename T>
    Matrix<T>::Matrix() : rows_(1), cols_(1)
    {
        allocSpace();
        p[0][0] = nullptr;
    }

    template<typename T>
    Matrix<T>::~Matrix()
    {
        for (size_t i = 0; i < rows_; ++i) {
            delete[] p[i];
        }
        delete[] p;
    }

    template<typename T>
    Matrix<T>::Matrix(const Matrix& m) : rows_(m.rows_), cols_(m.cols_)
    {
        allocSpace();
        for (size_t i = 0; i < rows_; ++i) {
            for (size_t j = 0; j < cols_; ++j) {
                p[i][j] = m.p[i][j];
            }
        }
    }

    template<typename T>
    Matrix<T>& Matrix<T>::operator=(const Matrix& m)
    {
        if (this == &m) {
            return *this;
        }

        if (rows_ != m.rows_ || cols_ != m.cols_) {
            for (size_t i = 0; i < rows_; ++i) {
                delete[] p[i];
            }
            delete[] p;

            rows_ = m.rows_;
            cols_ = m.cols_;
            allocSpace();
        }

        for (size_t i = 0; i < rows_; ++i) {
            for (size_t j = 0; j < cols_; ++j) {
                p[i][j] = m.p[i][j];
            }
        }
        return *this;
    }

    template<typename T>
    void Matrix<T>::swapRows(size_t r1, size_t r2)
    {
        T** temp = p[r1];
        p[r1] = p[r2];
        p[r2] = temp;
    }

    template<typename T>
    Matrix<T> Matrix<T>::transpose()
    {
        Matrix ret(cols_, rows_);
        for (size_t i = 0; i < rows_; ++i) {
            for (size_t j = 0; j < cols_; ++j) {
                ret.p[j][i] = p[i][j];
            }
        }
        return ret;
    }

    template<typename T>
    void Matrix<T>::clear()
    {
        for (size_t i = 0; i < rows_; ++i) {
            for (size_t j = 0; j < cols_; ++j) {
                p[i][j] = nullptr;
            }
        }
    }

    template<typename T>
    size_t Matrix<T>::getRows() const 
    { 
        return rows_; 
    }

    template<typename T>
    size_t Matrix<T>::getCols() const 
    { 
        return cols_; 
    }

    template<typename T>
    void Matrix<T>::allocSpace()
    {
        p = new T**[rows_];
        for (size_t i = 0; i < rows_; ++i) {
            p[i] = new T*[cols_];
        }
    }

    template<typename T>
    std::ostream& operator<<(std::ostream& os, const Matrix<T>& m)
    {
        for (size_t i = 0; i < m.rows_; ++i) {
            if (m.p[i][0] == nullptr) {
                os << "nullptr";
            } else {
                os << m.p[i][0];
            }
            for (size_t j = 1; j < m.cols_; ++j) {
                if (m.p[i][j] == nullptr) {
                    os << " nullptr";
                } else {
                    os << " " << m.p[i][j];
                }
            }
            os << std::endl;
        }
        return os;
    }
}

#endif //MATRIX_H

