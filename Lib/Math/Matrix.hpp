//
// Created by villerot on 17/03/25.
// Updated by villerot on 01/10/25.
// Documentation generated by ChatGPT
//

#ifndef MATRIX_H
#define MATRIX_H

#include <iostream>

namespace math {
    /**
     * Template class representing a matrix of objects of type T.
     * Provides basic matrix operations.
     */
    template<typename T>
    class Matrix {
    public:

        #pragma region Constructors_Destructors
        
        Matrix(size_t rows, size_t cols);
        Matrix(size_t rows, size_t cols, const T& initialValue);
        Matrix(const T* const* a, size_t rows, size_t cols);
        ~Matrix();

        #pragma endregion

        #pragma region Copy_Move

        Matrix(const Matrix& other);
        Matrix(Matrix&& other) noexcept;
        Matrix& operator=(const Matrix& other);
        Matrix& operator=(Matrix&& other) noexcept;

        #pragma endregion

        #pragma region Element_Access

        inline T& operator()(const size_t x, const size_t y) { return p[x][y]; }
        inline const T& operator()(const size_t x, const size_t y) const { return p[x][y]; }

        #pragma endregion

        #pragma region Utility_Methods

        void swapRows(size_t r1, size_t r2);
        Matrix transpose();
        void clear();
        size_t getRows() const;
        size_t getCols() const;
        
        template<typename U>
        friend std::ostream& operator<<(std::ostream& os, const Matrix<U>& m);

        #pragma endregion

    private:
        size_t rows_{0}, cols_{0}; ///< Number of rows and columns
        T **p{nullptr}; /// Pointer to the 2D array holding the matrix

        void allocSpace();
        void freeSpace();
    };

    /* TEMPLATE IMPLEMENTATION */

    /**
     * @brief Allocates memory for the matrix.
     */
    template<typename T>
    void Matrix<T>::allocSpace() {
        if (rows_ == 0 || cols_ == 0) {
            p = nullptr;
            return;
        }

        p = new T*[rows_];
        for (size_t i = 0; i < rows_; ++i) {
            p[i] = new T[cols_];
        }
    }

    /**
     * @brief Frees the allocated memory for the matrix.
     */
    template<typename T>
    void Matrix<T>::freeSpace() {
        if (p != nullptr) {
            for (size_t i = 0; i < rows_; ++i) {
                delete[] p[i];
            }
            delete[] p;
            p = nullptr;
        }
    }

    /**
     * @brief Constructor to create a matrix with given rows and columns.
     */
    template<typename T>
    Matrix<T>::Matrix(size_t rows, size_t cols) : rows_(rows), cols_(cols) {
        allocSpace();
        for (size_t i = 0; i < rows_; ++i) {
            for (size_t j = 0; j < cols_; ++j) {
                p[i][j] = T{};
            }
        }
    }

    /**
     * @brief Constructor to create a matrix with given rows, columns, and initial value.
     */
    template<typename T>
    Matrix<T>::Matrix(size_t rows, size_t cols, const T& initialValue) : rows_(rows), cols_(cols) {
        allocSpace();
        for (size_t i = 0; i < rows_; ++i) {
            for (size_t j = 0; j < cols_; ++j) {
                p[i][j] = initialValue;
            }
        }
    }

    /**
     * @brief Constructor to create a matrix from a 2D array.
     */
    template<typename T>
    Matrix<T>::Matrix(const T* const* a, size_t rows, size_t cols) : rows_(rows), cols_(cols) {
        allocSpace();
        for (size_t i = 0; i < rows_; ++i) {
            for (size_t j = 0; j < cols_; ++j) {
                p[i][j] = a[i][j];
            }
        }
    }

    /**
     * @brief Destructor to free allocated memory.
     */
    template<typename T>
    Matrix<T>::~Matrix() {
        freeSpace();
    }

    /**
     * @brief Copy constructor.
     */
    template<typename T>
    Matrix<T>::Matrix(const Matrix& other) : rows_(other.rows_), cols_(other.cols_) {
        allocSpace();
        for (size_t i = 0; i < rows_; ++i) {
            for (size_t j = 0; j < cols_; ++j) {
                p[i][j] = other.p[i][j];
            }
        }
    }

    /**
     * @brief Move constructor.
     */
    template<typename T>
    Matrix<T>::Matrix(Matrix&& other) noexcept : rows_(other.rows_), cols_(other.cols_), p(other.p) {
        other.rows_ = 0;
        other.cols_ = 0;
        other.p = nullptr;
    }

    /**
     * @brief Copy assignment operator.
     */
    template<typename T>
    Matrix<T>& Matrix<T>::operator=(const Matrix& other) {
        if (this == &other) {
            return *this;
        }

        freeSpace();
        rows_ = other.rows_;
        cols_ = other.cols_;
        allocSpace();
        for (size_t i = 0; i < rows_; ++i) {
            for (size_t j = 0; j < cols_; ++j) {
                p[i][j] = other.p[i][j];
            }
        }
        return *this;
    }

    /**
     * @brief Move assignment operator.
     */
    template<typename T>
    Matrix<T>& Matrix<T>::operator=(Matrix&& other) noexcept {
        if (this == &other) {
            return *this;
        }

        freeSpace();
        rows_ = other.rows_;
        cols_ = other.cols_;
        p = other.p;

        other.rows_ = 0;
        other.cols_ = 0;
        other.p = nullptr;

        return *this;
    }

    /**
     * @brief Swaps two rows in the matrix.
     */
    template<typename T>
    void Matrix<T>::swapRows(size_t r1, size_t r2) {
        if (r1 >= rows_ || r2 >= rows_) {
            throw std::out_of_range("Row index out of bounds");
        }
        T* temp = p[r1];
        p[r1] = p[r2];
        p[r2] = temp;
    }

    /**
     * @brief Transposes the matrix.
     */
    template<typename T>
    Matrix<T> Matrix<T>::transpose() {
        Matrix<T> transposed(cols_, rows_);
        for (size_t i = 0; i < rows_; ++i) {
            for (size_t j = 0; j < cols_; ++j) {
                transposed.p[j][i] = p[i][j];
            }
        }
        return transposed;
    }

    /**
     * @brief Clears the matrix by setting all elements to default value.
     */
    template<typename T>
    void Matrix<T>::clear() {
        for (size_t i = 0; i < rows_; ++i) {
            for (size_t j = 0; j < cols_; ++j) {
                p[i][j] = T{};
            }
        }
    }

    /**
     * @brief Returns the number of rows in the matrix.
     */
    template<typename T>
    size_t Matrix<T>::getRows() const {
        return rows_;
    }

    /**
     * @brief Returns the number of columns in the matrix.
     */
    template<typename T>
    size_t Matrix<T>::getCols() const {
        return cols_;
    }

    /**
     * @brief Output stream operator for debugging purposes.
     */
    template<typename T>
    std::ostream& operator<<(std::ostream& os, const Matrix<T>& m) {
        for (size_t i = 0; i < m.rows_; ++i) {
            for (size_t j = 0; j < m.cols_; ++j) {
                os << m.p[i][j] << " ";
            }
            os << std::endl;
        }
        return os;
    }

// Barrier barrier don't touch the } on the next line for the omnissiah sake
}
#endif //MATRIX_H

