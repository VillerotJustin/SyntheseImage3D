//
// Created by villerot on 17/03/25.
// Updated by villerot on 03/10/25.
// Documentation generated by ChatGPT
// Based of the work of vraid
// Original was vector 3 only
// https://github.com/vraid/earthgen-old/blob/master/source/math/vector3.h
//

#ifndef VECTOR_H
#define VECTOR_H

#include <iostream>

namespace math {

    /**
     * @class Vector
     * @brief Template class representing a vector of objects of type T.
     * 
     * This class provides basic functionality for vector-like containers, similar to the Matrix template class. It stores objects rather than pointers to objects.
     */
    template<typename T>
    class Vector {
    public:
        #pragma region Constructors_Destructors
        
        explicit Vector(size_t size);
        Vector(const T* data, size_t size);
        Vector();
        ~Vector();

        #pragma endregion

        #pragma region Copy_Move
        
        Vector(const Vector& other);
        Vector(Vector&& other) noexcept;
        Vector& operator=(const Vector& other);
        Vector& operator=(Vector&& other) noexcept;

        #pragma endregion

        #pragma region Element_Access

        T& operator[](size_t index);
        const T& operator[](size_t index) const;

        [[nodiscard]] size_t size() const { return m_size; }

        #pragma endregion

        #pragma region Utility_Methods

        void clear();          // set size to 0 and free storage
        bool empty() const;    // true if size == 0

        void append(const T& element);
        void insert(size_t index, const T& element);
        void erase(size_t index);

        T* begin() { return elements; }
        const T* begin() const { return elements; }
        T* end() { return elements + m_size; }
        const T* end() const { return elements + m_size; }

    bool operator==(const Vector& other) const noexcept;
    bool operator!=(const Vector& other) const noexcept;
        bool operator!=(const Vector&& other) noexcept;

        template<typename U>
        friend std::ostream& operator<<(std::ostream& os, const Vector<U>& v);

        #pragma endregion

    private:
        size_t m_size{0};     ///< The number of elements in the vector.
        T *elements{nullptr};   ///< Array of pointers to objects of type T.

        void allocateSpace(size_t n);
        void freeSpace();
    };

    /* TEMPLATE IMPLEMENTATION */

    /**
     * @brief Utility function that initializes the vector with a specified size.
     * @param size The initial size of the vector.
     */
    template<typename T>
    void Vector<T>::allocateSpace(size_t n) {
        if (n == 0) {
            elements = nullptr;
            return;
        }
        elements = new T[n];
    }

    /**
     * @brief Utility function to free allocated memory.
     */
    template<typename T>
    void Vector<T>::freeSpace() {
        delete[] elements;
        elements = nullptr;
    }

    /**
     * @brief Constructor that initializes the vector with a specified size.
     * @param size The initial size of the vector.
     */
    template<typename T>
    Vector<T>::Vector(size_t size) : m_size(size) {
        if (m_size > 0) {
            allocateSpace(m_size);
            for (size_t i = 0; i < m_size; ++i) elements[i] = T{};
        }
    }

    /**
     * @brief Constructor that initializes the vector from a given array.
     * @param data Pointer to the array of objects to copy from.
     * @param size The number of elements to copy.
     */
    template<typename T>
    Vector<T>::Vector(const T* data, size_t size) : m_size(size) {
        if (m_size > 0) {
            allocateSpace(m_size);
            for (size_t i = 0; i < m_size; ++i) elements[i] = data[i];
        }
    }

    
    /**
     * @brief Default constructor creating an empty vector.
     */
    template<typename T>
    Vector<T>::Vector() : m_size(0), elements(nullptr) {}

    /**
     * @brief Destructor to free allocated memory.
     */
    template<typename T>
    Vector<T>::~Vector() {
        freeSpace();
    }

    /**
     * @brief Copy constructor.
     * @param other The vector to copy from.
     */
    template<typename T>
    Vector<T>::Vector(const Vector& other) : m_size(other.m_size) {
        if (m_size > 0) {
            allocateSpace(m_size);
            for (size_t i = 0; i < m_size; ++i) elements[i] = other.elements[i];
        }
    }

    /**
     * @brief Move constructor.
     * @param other The vector to move from.
     */
    template<typename T>
    Vector<T>::Vector(Vector&& other) noexcept : m_size(other.m_size), elements(other.elements) {
        other.m_size = 0;
        other.elements = nullptr;
    }

    /**
     * @brief Copy assignment operator.
     * @param other The vector to copy from.
     * @return Reference to this vector.
     */
    template<typename T>
    Vector<T>& Vector<T>::operator=(const Vector& other) {
        if (this == &other) return *this;
        if (m_size != other.m_size) {
            freeSpace();
            m_size = other.m_size;
            if (m_size > 0) allocateSpace(m_size);
        }
        for (size_t i = 0; i < m_size; ++i) elements[i] = other.elements[i];
        return *this;
    }

    /**
     * @brief Move assignment operator.
     * @param other The vector to move from.
     * @return Reference to this vector.
     */
    template<typename T>
    Vector<T>& Vector<T>::operator=(Vector&& other) noexcept {
        if (this == &other) return *this;
        freeSpace();
        m_size = other.m_size;
        elements = other.elements;
        other.m_size = 0;
        other.elements = nullptr;
        return *this;
    }

    /**
     * @brief Equiality comparaison operator
     */
    template<typename T>
    bool Vector<T>::operator==(const Vector<T>& other) const noexcept {
        if (m_size != other.m_size) return false;
        for (size_t i = 0; i < m_size; ++i) {
            if (elements[i] != other.elements[i]) return false;
        }
        return true;
    }

    /**
     * @brief Inequality comparaison operator
     */
    template<typename T>
    bool Vector<T>::operator!=(const Vector<T>& other) const noexcept {
        return !(this == &other);
    }

    /**
     * @brief Subscript operator for element access.
     * @param index The index of the element to access.
     * @return Reference to the element at the specified index.
     */
    template<typename T>
    T& Vector<T>::operator[](size_t index) {
        if (index >= m_size) throw std::out_of_range("Vector index out of bounds");
        return elements[index];
    }

    /**
     * @brief Subscript operator for const element access.
     * @param index The index of the element to access.
     * @return Const reference to the element at the specified index.
     */
    template<typename T>
    const T& Vector<T>::operator[](size_t index) const {
        if (index >= m_size) throw std::out_of_range("Vector index out of bounds");
        return elements[index];
    }

    /**
     * @brief Clears the vector by setting its size to zero and freeing storage.
     */
    template<typename T>
    void Vector<T>::clear() {
        freeSpace();
        m_size = 0;
    }

    /**
     * @brief Checks if the vector is empty.
     * @return True if the vector is empty, false otherwise.
     */
    template<typename T>
    bool Vector<T>::empty() const {
        return m_size == 0;
    }

    /**
     * @brief Appends an element to the end of the vector.
     * @param element The element to append.
     */
    template<typename T>
    void Vector<T>::append(const T& element) {
        T* newElements = new T[m_size + 1];
        for (size_t i = 0; i < m_size; ++i) {
            newElements[i] = elements[i];
        }
        newElements[m_size] = element;
        freeSpace();
        elements = newElements;
        ++m_size;
    }

    /**
     * @brief Inserts an element at the specified index.
     * @param index The index to insert the element at.
     * @param element The element to insert.
     */
    template<typename T>
    void Vector<T>::insert(size_t index, const T& element) {
        if (index > m_size) throw std::out_of_range("Vector index out of bounds");
        T* newElements = new T[m_size + 1];
        for (size_t i = 0; i < index; ++i) {
            newElements[i] = elements[i];
        }
        newElements[index] = element;
        for (size_t i = index; i < m_size; ++i) {
            newElements[i + 1] = elements[i];
        }
        freeSpace();
        elements = newElements;
        ++m_size;
    }

    /**
     * @brief Erases the element at the specified index.
     * @param index The index of the element to erase.
     */
    template<typename T>
    void Vector<T>::erase(size_t index) {
        if (index >= m_size) throw std::out_of_range("Vector index out of bounds");
        T* newElements = new T[m_size - 1];
        for (size_t i = 0; i < index; ++i) {
            newElements[i] = elements[i];
        }
        for (size_t i = index + 1; i < m_size; ++i) {
            newElements[i - 1] = elements[i];
        }
        freeSpace();
        elements = newElements;
        --m_size;
    }

    /**
     * @brief Output stream operator for debugging purposes.
     * @param os The output stream.
     * @param v The vector to output.
     * @return Reference to the output stream.
     */
    template<typename T>
    std::ostream& operator<<(std::ostream& os, const Vector<T>& v) {
        os << "Vector(size=" << v.m_size << ", elements=[";
        for (size_t i = 0; i < v.m_size; ++i) {
            os << v.elements[i];
            if (i < v.m_size - 1) os << ", ";
        }
        os << "])";
        return os;
    }


// Barrier barrier don't touch the } on the next line for the omnissiah sake
} // namespace math





#endif //VECTOR_H
