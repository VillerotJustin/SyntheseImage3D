//
// Created by villerot on 17/03/25.
// Updated by villerot on 03/10/25.
// Documentation generated by ChatGPT
// Based of the work of vraid
// Original was vector 3 only
// https://github.com/vraid/earthgen-old/blob/master/source/math/vector3.h
//

#ifndef VECTOR_H
#define VECTOR_H

#include <iostream>

namespace math {

    /**
     * @class Vector
     * @brief Template class representing a vector of pointers to objects of type T.
     * 
     * This class provides basic pointer management functionality for vector-like
     * containers, similar to the Matrix template class. It stores pointers to
     * objects rather than the objects themselves.
     */
    template<typename T>
    class Vector {
    public:
        /**
         * @brief Constructor that creates a vector of size 'size' with all pointers initialized to nullptr.
         * @param size The size of the vector.
         */
        explicit Vector(int size);

        /**
         * @brief Constructor that creates a vector from an array of pointers.
         * @param data Array of pointers to initialize the vector.
         * @param size The size of the vector.
         */
        Vector(T** data, int size);

        /**
         * @brief Default constructor that creates an empty vector.
         */
        Vector();

        /**
         * @brief Destructor that deallocates the memory used by the vector.
         * Note: This does NOT delete the objects pointed to by the pointers.
         */
        ~Vector();

        /**
         * @brief Copy constructor that creates a new vector by copying pointer values.
         * This performs a shallow copy - the actual objects are not duplicated.
         * @param other The vector to copy.
         */
        Vector(const Vector& other);

        /**
         * @brief Assignment operator that copies pointer values from another vector.
         * This performs a shallow copy - the actual objects are not duplicated.
         * @param other The vector to copy.
         * @return Reference to this vector after assignment.
         */
        Vector& operator=(const Vector& other);

        /**
         * @brief Equality operator that compares pointer values.
         * @param other The vector to compare with.
         * @return True if all pointers are equal, false otherwise.
         */
        bool operator==(const Vector& other) const;

        /**
         * @brief Inequality operator that compares pointer values.
         * @param other The vector to compare with.
         * @return True if any pointers are different, false otherwise.
         */
        bool operator!=(const Vector& other) const;

        /**
         * @brief Accessor method to get the pointer at a specific index.
         * @param index The index of the element to access.
         * @return Reference to the pointer at the specified index.
         * @throws std::out_of_range if index is out of bounds.
         */
        T*& operator[](int index);

        /**
         * @brief Accessor method to get the pointer at a specific index (const version).
         * @param index The index of the element to access.
         * @return Const reference to the pointer at the specified index.
         * @throws std::out_of_range if index is out of bounds.
         */
        const T* operator[](int index) const;

        /**
         * @brief Method to get the size of the vector.
         * @return The number of elements in the vector.
         */
        [[nodiscard]] int size() const { return m_size; }

        /**
         * @brief Sets all pointers in the vector to nullptr.
         */
        void clear();

        /**
         * @brief Check if all pointers in the vector are nullptr.
         * @return True if all pointers are nullptr, false otherwise.
         */
        bool empty() const;

        void append(T* element);

        /**
         * @brief Insert an element at a specific position.
         * @param index The position where to insert the element.
         * @param element The element to insert.
         * @throws std::out_of_range if index is out of bounds.
         */
        void insert(int index, T* element);

        /**
         * @brief Remove an element at a specific position.
         * @param index The position of the element to remove.
         * @throws std::out_of_range if index is out of bounds.
         */
        void erase(int index);

        /**
         * @brief Returns a pointer to the first element (iterator begin).
         * @return Pointer to the first element.
         */
        T** begin() { return elements; }

        /**
         * @brief Returns a const pointer to the first element (iterator begin).
         * @return Const pointer to the first element.
         */
        const T* const* begin() const { return elements; }

        /**
         * @brief Returns a pointer to past-the-end element (iterator end).
         * @return Pointer to past-the-end element.
         */
        T** end() { return elements + m_size; }

        /**
         * @brief Returns a const pointer to past-the-end element (iterator end).
         * @return Const pointer to past-the-end element.
         */
        const T* const* end() const { return elements + m_size; }

        /**
         * @brief Output stream operator for debugging purposes.
         * @param os The output stream.
         * @param v The vector to output.
         * @return The output stream.
         */
        template<typename U>
        friend std::ostream& operator<<(std::ostream& os, const Vector<U>& v);

    private:
        int m_size;     ///< The number of elements in the vector.
        T** elements;   ///< Array of pointers to objects of type T.

        /**
         * @brief Allocates memory for the pointer array.
         */
        void allocateSpace();
    };

    /* TEMPLATE IMPLEMENTATION */

    template<typename T>
    Vector<T>::Vector(int size) : m_size(size) {
        if (m_size > 0) {
            allocateSpace();
            for (int i = 0; i < m_size; ++i) {
                elements[i] = nullptr;
            }
        } else {
            elements = nullptr;
        }
    }

    template<typename T>
    Vector<T>::Vector(T** data, int size) : m_size(size) {
        if (m_size > 0) {
            allocateSpace();
            for (int i = 0; i < m_size; ++i) {
                elements[i] = data[i];
            }
        } else {
            elements = nullptr;
        }
    }

    template<typename T>
    Vector<T>::Vector() : m_size(0), elements(nullptr) {
    }

    template<typename T>
    Vector<T>::~Vector() {
        delete[] elements;
    }

    template<typename T>
    Vector<T>::Vector(const Vector& other) : m_size(other.m_size) {
        if (m_size > 0) {
            allocateSpace();
            for (int i = 0; i < m_size; ++i) {
                elements[i] = other.elements[i];
            }
        } else {
            elements = nullptr;
        }
    }

    template<typename T>
    Vector<T>& Vector<T>::operator=(const Vector& other) {
        if (this == &other) {
            return *this;
        }

        if (m_size != other.m_size) {
            delete[] elements;
            m_size = other.m_size;
            if (m_size > 0) {
                allocateSpace();
            } else {
                elements = nullptr;
            }
        }

        for (int i = 0; i < m_size; ++i) {
            elements[i] = other.elements[i];
        }
        return *this;
    }

    template<typename T>
    bool Vector<T>::operator==(const Vector& other) const {
        if (m_size != other.m_size) {
            return false;
        }
        for (int i = 0; i < m_size; ++i) {
            if (elements[i] != other.elements[i]) {
                return false;
            }
        }
        return true;
    }

    template<typename T>
    bool Vector<T>::operator!=(const Vector& other) const {
        return !(*this == other);
    }

    template<typename T>
    T*& Vector<T>::operator[](int index) {
        if (index < 0 || index >= m_size) {
            throw std::out_of_range("Vector index out of bounds");
        }
        return elements[index];
    }

    template<typename T>
    const T* Vector<T>::operator[](int index) const {
        if (index < 0 || index >= m_size) {
            throw std::out_of_range("Vector index out of bounds");
        }
        return elements[index];
    }

    template<typename T>
    void Vector<T>::clear() {
        for (int i = 0; i < m_size; ++i) {
            elements[i] = nullptr;
        }
    }

    template<typename T>
    bool Vector<T>::empty() const {
        for (int i = 0; i < m_size; ++i) {
            if (elements[i] != nullptr) {
                return false;
            }
        }
        return true;
    }

    template<typename T>
    void Vector<T>::allocateSpace() {
        elements = new T*[m_size];
    }

    template<typename T>
    void Vector<T>::append(T* element) {
        T** newElements = new T*[m_size + 1];
        for (int i = 0; i < m_size; ++i) {
            newElements[i] = elements[i];
        }
        newElements[m_size] = element;
        delete[] elements;
        elements = newElements;
        ++m_size;
    }

    template<typename T>
    void Vector<T>::insert(int index, T* element) {
        if (index < 0 || index > m_size) {
            throw std::out_of_range("Vector index out of bounds");
        }
        
        T** newElements = new T*[m_size + 1];
        
        // Copy elements before the insertion point
        for (int i = 0; i < index; ++i) {
            newElements[i] = elements[i];
        }
        
        // Insert the new element
        newElements[index] = element;
        
        // Copy elements after the insertion point
        for (int i = index; i < m_size; ++i) {
            newElements[i + 1] = elements[i];
        }
        
        delete[] elements;
        elements = newElements;
        ++m_size;
    }

    template<typename T>
    void Vector<T>::erase(int index) {
        if (index < 0 || index >= m_size) {
            throw std::out_of_range("Vector index out of bounds");
        }
        
        if (m_size == 1) {
            delete[] elements;
            elements = nullptr;
            m_size = 0;
            return;
        }
        
        T** newElements = new T*[m_size - 1];
        
        // Copy elements before the removal point
        for (int i = 0; i < index; ++i) {
            newElements[i] = elements[i];
        }
        
        // Copy elements after the removal point
        for (int i = index + 1; i < m_size; ++i) {
            newElements[i - 1] = elements[i];
        }
        
        delete[] elements;
        elements = newElements;
        --m_size;
    }

    template<typename T>
    std::ostream& operator<<(std::ostream& os, const Vector<T>& v) {
        os << "[";
        for (int i = 0; i < v.m_size; ++i) {
            if (i > 0) os << ", ";
            if (v.elements[i] == nullptr) {
                os << "nullptr";
            } else {
                os << v.elements[i];
            }
        }
        os << "]";
        return os;
    }

} // namespace geometry





#endif //VECTOR_H
