//
// Created by villerot on 17/03/25.
// Documentation generated by ChatGPT
// Based of Vraid Code
// https://github.com/vraid/earthgen-old/blob/master/source/math/quaternion.cpp
//

#include "Quaternion.h"
#include "Vector.h"
#include "Matrix.h"
#include "math_common.h"
#include <cmath>

namespace math {

	/**
	 * @brief Default constructor for Quaternion.
	 *
	 * Initializes the quaternion with all components set to [1, 0, 0, 0].
	 * This represents the identity quaternion.
	 */
	Quaternion::Quaternion () : values ({1, 0, 0, 0}) {}

	/**
	 * @brief Parameterized constructor for Quaternion.
	 *
	 * Initializes the quaternion with the specified components.
	 *
	 * @param a The real component of the quaternion.
	 * @param i The first imaginary component of the quaternion.
	 * @param j The second imaginary component of the quaternion.
	 * @param k The third imaginary component of the quaternion.
	 */
	Quaternion::Quaternion (double a, double i, double j, double k) : values ({a, i, j, k}) {}

	/**
	 * @brief Creates a quaternion representing a rotation around a given axis by a specified angle.
	 *
	 * This function creates a quaternion that represents a rotation by an angle (in radians) around the specified axis (a vector).
	 *
	 * @param axis The vector representing the axis of rotation.
	 * @param angle The angle (in radians) to rotate around the axis.
	 * @return A quaternion representing the rotation.
	 */
	Quaternion rotation_around (const Vector& axis, double angle) {
		Vector v = normal(axis)*std::sin(angle*0.5);
		return Quaternion(std::cos(angle*0.5), v.at(0), v.at(1), v.at(2));
	}

	/**
     * @brief Creates a quaternion representing the rotation between two non-parallel vectors.
     *
     * This function computes the quaternion that represents the rotation from vector `a` to vector `b` assuming they are non-parallel.
     *
     * @param a The initial vector.
     * @param b The target vector.
     * @return A quaternion representing the rotation from `a` to `b`.
     */
    Quaternion rotation_between_nonparallel (const Vector& a, const Vector& b) {
        return rotation_around(cross_product_3d(b, a), -std::acos(dot_product(a, b)));
    }

    /**
     * @brief Creates a quaternion representing the rotation between two parallel vectors.
     *
     * This function computes the quaternion that represents the rotation between two parallel vectors `a` and `b`.
     * If the vectors are not equal, an intermediate vector is chosen to break down the rotation into two non-parallel rotations.
     *
     * @param a The initial vector.
     * @param b The target vector.
     * @return A quaternion representing the rotation from `a` to `b`.
     */
    Quaternion rotation_between_parallel (const Vector& a, const Vector& b) {
        if (a != b) {
            const Vector intermediate = parallel(a, Vector({1, 0, 0})) ? Vector({0, 1, 0}) : Vector({1, 0, 0});
            return rotation_between_nonparallel(intermediate, b) * rotation_between_nonparallel(a, intermediate);
        }
        else {
            return Quaternion();
        }
    }

    /**
     * @brief Creates a quaternion representing the rotation between two vectors (handles both parallel and non-parallel cases).
     *
     * This function first normalizes the vectors `a` and `b`, then uses `rotation_between_parallel` or `rotation_between_nonparallel`
     * to compute the quaternion depending on whether the vectors are parallel or not.
     *
     * @param a The initial vector.
     * @param b The target vector.
     * @return A quaternion representing the rotation from `a` to `b`.
     */
    Quaternion rotation_between (const Vector& a, const Vector& b) {
        Vector v = normal(a);
        Vector u = normal(b);
        return (parallel(v, u)) ? rotation_between_parallel(v, u) : rotation_between_nonparallel(v, u);
    }

    /**
     * @brief Overloaded multiplication operator for quaternions.
     *
     * This function multiplies the current quaternion by another quaternion `q` and returns the resulting quaternion.
     *
     * @param q The quaternion to multiply with.
     * @return A new quaternion that is the result of multiplying this quaternion with `q`.
     */
    Quaternion Quaternion::operator * (const Quaternion& q) const {
        auto p = [=](int n, int k) { return at(n)*q.at(k); };
        return normal(
            Quaternion(
                p(0,0) - p(1,1) - p(2,2) - p(3,3),
                p(0,1) + p(1,0) + p(2,3) - p(3,2),
                p(0,2) - p(1,3) + p(2,0) + p(3,1),
                p(0,3) + p(1,2) - p(2,1) + p(3,0)));
    }

    /**
     * @brief Overloaded multiplication operator for rotating a vector using a quaternion.
     *
     * This function rotates the given vector `v` using the current quaternion.
     *
     * @param v The vector to rotate.
     * @return A new vector that is the result of rotating `v` by this quaternion.
     */
    Vector Quaternion::operator * (const Vector &v) const {
        return (zero(v)) ? v : vector((*this) * (Quaternion(0, v.x(), v.y(), v.z()) * conjugate(*this)));
    }

    /**
     * @brief Computes the conjugate of a quaternion.
     *
     * The conjugate of a quaternion is obtained by flipping the signs of the imaginary components (x, y, z) while keeping the real part (w) unchanged.
     *
     * @param q The quaternion to conjugate.
     * @return The conjugate of the quaternion `q`.
     */
    Quaternion conjugate (const Quaternion& q) {
        return Quaternion(q.at(0), -q.at(1), -q.at(2), -q.at(3));
    }

	/**
	 * @brief Extracts the vector part (the imaginary part) of a quaternion.
	 *
	 * This function extracts the imaginary part (x, y, z) of the quaternion, leaving out the real part (w).
	 *
	 * @param q The quaternion to extract the vector part from.
	 * @return A vector representing the imaginary part of the quaternion.
	 */
	Vector vector (const Quaternion& q) {
		return Vector({q.at(1), q.at(2), q.at(3)});
	}

	/**
	 * @brief Normalizes a quaternion.
	 *
	 * This function normalizes a quaternion by scaling it such that its length becomes 1, resulting in a unit quaternion.
	 *
	 * @param q The quaternion to normalize.
	 * @return The normalized quaternion.
	 */
	Quaternion normal (const Quaternion& q) {
		double a = q.at(0);
		double i = q.at(1);
		double j = q.at(2);
		double k = q.at(3);
		double d = std::sqrt(square(a) + square(i) + square(j) + square(k));
		return Quaternion(a/d, i/d, j/d, k/d);
	}

	/**
	 * @brief Converts a quaternion to a 3x3 rotation matrix.
	 *
	 * This function converts a quaternion to a 3x3 matrix that represents the rotation defined by the quaternion.
	 *
	 * @param q The quaternion to convert.
	 * @return A 3x3 matrix representing the rotation defined by the quaternion `q`.
	 */
	Matrix matrix3 (const Quaternion& q) {
		auto p = [=](int n, int k) { return q.at(n)*q.at(k); };
    	double ** matrix_data = new double *[3];
    	// Allocate memory for each row (double*)
    	for (int i = 0; i < 3; ++i) {
    		matrix_data[i] = new double[3];
    	}
    	// Manually assign values to the matrix
    	matrix_data[0][0] = -(p(2,2) + p(3,3));
    	matrix_data[0][1] = p(1,2) - p(0,3);
    	matrix_data[0][2] = p(1,3) + p(0,2);

    	matrix_data[1][0] = p(1,2) + p(0,3);
    	matrix_data[1][1] = -(p(1,1) + p(3,3));
    	matrix_data[1][2] = p(2,3) - p(0,1);

    	matrix_data[2][0] = p(1,3) - p(0,2);
    	matrix_data[2][1] = p(2,3) + p(0,1);
    	matrix_data[2][2] = -(p(1,1) + p(2,2));

		Matrix m(matrix_data,3,3);

		return Matrix(3, 3) + m + m;
	}

}